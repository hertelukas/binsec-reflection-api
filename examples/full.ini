# start the analysis at <main>
# with all concrete values read from coredump
starting from core
# stop exploration when <main> returns
halt at @[rsp, 8]

# cover all paths
explore all

# Core Reflection Primitives
abort at <error>
abort at <state_constraints>
abort at <print_byte>
abort at <print_constraint>
abort at <maximize>
abort at <minimize>

replace <is_symbolic> (var, length) by
    res:=is_symbolic(var, length)
    return uext64 res
end

abort at <new_sym_var>
abort at <new_sym_var_array>
abort at <is_sat>

replace <assume> (cnstr) by
    assume cnstr <> 0
    return
end

abort at <eval>

# Memory Primitives
abort at <mem_alloc>
abort at <mem_bytes>
abort at <mem_free>

# Symbolic Value Primitives
abort at <_solver_Concat>
abort at <_solver_Extract>
abort at <_solver_ZeroExt>
abort at <_solver_SignExt>

# Constraint Primitives
abort at <_solver_NOT>
abort at <_solver_Or>
abort at <_solver_And>
abort at <_solver_EQ>
abort at <_solver_NEQ>
abort at <_solver_LT>
abort at <_solver_LE>
abort at <_solver_SLT>
abort at <_solver_SLE>
abort at <_solver_ITE>
abort at <_solver_ITE_VAR>

# Summary Validation
abort at <save_current_state>
abort at <mem_addr>
abort at <get_cnstr>
abort at <store_cnstr>
abort at <halt_all>
abort at <check_implications>
abort at <print_counterexamples>
