# start the analysis at <main>
# with all concrete values read from coredump
starting from core
# stop exploration when <main> returns
halt at @[rsp, 8]

# cover all paths
explore all

# Core Reflection Primitives
replace <error> (msg) by
    error(msg)
    return
end

abort at <state_constraints>

replace <print_byte> (byte) by
    print_byte(byte)
    return
end

replace <print_constraint> (cnstr_print) by
    print_constraint(cnstr_print)
    return
end

replace <maximize> (var_max, length_max) by
    res_maximize:=maximize(var_max, length_max)
    return res_maximize
end

replace <minimize> (var_min, length_min) by
    res_minimize:=minimize(var_min, length_min)
    return res_minimize
end

replace <is_symbolic> (var_sym, length_sym) by
    res_is_symbolic:=is_symbolic(var_sym, length_sym)
    return uext64 res_is_symbolic
end

replace <new_sym_var> (length_new_sym) by
    res_new_sym_var:=new_sym_var(length_new_sym)
    return uext64 res_new_sym_var
end

abort at <new_sym_var_named>
abort at <new_sym_var_array>

replace <is_sat> (cnstr_sat) by
    res_is_sat:=is_sat(cnstr_sat)
    return uext64 res_is_sat
end

replace <assume> (cnstr_ass) by
    assume cnstr_ass <> 0
    return
end

abort at <eval>

# Memory Primitives
abort at <mem_alloc>
abort at <mem_bytes>
abort at <mem_free>

# Symbolic Value Primitives
abort at <_solver_Concat>
abort at <_solver_Extract>
abort at <_solver_ZeroExt>
abort at <_solver_SignExt>

# Constraint Primitives
replace <_solver_NOT> (cnstr_not) by
    res_not:=_solver_NOT(cnstr_not)
    return uext64 res_not
end

replace <_solver_Or> (cnstr_or_1, cnstr_or_2) by
    res_or:=_solver_Or(cnstr_or_1, cnstr_or_2)
    return uext64 res_or
end

replace <_solver_And> (cnstr_and_1, cnstr_and_2) by
    res_and:=_solver_And(cnstr_and_1, cnstr_and_2)
    return uext64 res_and
end

replace <_solver_EQ> (sym_var_eq_1, sym_var_eq_2, length_eq) by
    res_eq:=_solver_EQ(sym_var_eq_1, sym_var_eq_2, length_eq)
    return uext64 res_eq
end

abort at <_solver_NEQ>
replace <_solver_LT> (sym_var_lt_1, sym_var_lt_2, length_lt) by
    res_lt:=_solver_LT(sym_var_lt_1, sym_var_lt_2, length_lt)
    return uext64 res_lt
end

replace <_solver_LE>(sym_var_le_1, sym_var_le_2, length_le) by
    res_le:=_solver_LE(sym_var_le_1, sym_var_le_2, length_le)
    return uext64 res_le
end

replace <_solver_SLT> (sym_var_slt_1, sym_var_slt_2, length_slt) by
    res_slt:=_solver_SLT(sym_var_slt_1, sym_var_slt_2, length_slt)
    return uext64 res_slt
end

replace <_solver_SLE> (sym_var_sle_1, sym_var_sle_2, length_sle) by
    res_sle:=_solver_SLE(sym_var_sle_1, sym_var_sle_2, length_sle)
    return uext64 res_sle
end

replace <_solver_ITE> (cond_ite, cnstr_ite_1, cnstr_ite_2) by
    res_ite:=_solver_ITE(cond_ite, cnstr_ite_1, cnstr_ite_2)
    return uext64 res_ite
end

replace <_solver_ITE_VAR> (cond_ite_var, sym_var_ite_1, sym_var_ite_2, length_ite_1, length_ite_2)
    res_ite_var:=_solver_ITE_VAR (cond_ite_var, sym_var_ite_1, sym_var_ite_2, length_ite_1, length_ite_2)
    return uext64 res_ite_var
end

# Summary Validation
abort at <save_current_state>
abort at <mem_addr>
abort at <get_cnstr>
abort at <store_cnstr>
abort at <halt_all>
abort at <check_implications>
abort at <print_counterexamples>
